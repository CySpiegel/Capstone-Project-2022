from genotype import *
import random

'''
Defining available tree node functions typically follows the following format:

@GeneticTree.declarePrimitive(roles, node_type, children_types)
def some_function(self, input_nodes, context):
	pass # functionality goes here

GeneticTree.declarePrimitive decorator parameters:
	roles = what types of agents can use this node (e.g. maybe only attackers
			can use exploits)
	node_type = what is the data type of this node
	children_types = 	data type for each expected child node (defines both
						how many children a node should have as well as their
						type)

Primitive function (some_function in this case) parameters:
	self = 	the calling Node object (useful for storing constant values in
			self.value but can otherwise be ignored and is automatically
			passed in by a function we'll discuss shortly)
	input_nodes = 	a list of children Node objects for execution and use in
					the function itself (see later example)
	context = 	data passed to children nodes (typically a dictionary, but could
				be any other object of your choice). Be mindful of Python's
				implicit pass-by-reference/value rules. If your context object
				is a mutable type, like a Dict, the values within may be
				modified by children nodes and you may need to reassign values
				between execution of children nodes if data is generated during
				tree execution and passed down.

By using this decorator, the function defined below is automatically defined
within the GeneticTree class as a possible node and added to an internal
dictionary that stores the function itself for later use. This allows for the
creation of GeneticTree objects that can be executed with the 
GeneticTree.execute method.

The GeneticTree.execute method takes as inputs self and context, where these
parameters are the same as defined above. Of note, however, is that the context
object needs to be formed prior to executing the tree and passed in as a
parameter. See the following example:

context = {'some key': 7, 'maybe an IP?': '192.168.0.1'}
some_already_formed_GeneticTree.execute(context)

The rest of this file is an executable example showing how you might use this
framework in practice:
'''

# defining types of agents as constant strings
ATTACKER = 'attacker'

# defining data types of primitives as constant strings
IP_ACTION = 'ip action'
IP_ADDRESS = 'ip address'

# only attackers can use this primitive, it's data type is IP_ACTION, and it 
# requires 2 IP_ACTION-type children nodes.
@GeneticTree.declarePrimitive(ATTACKER, IP_ACTION, (IP_ACTION, IP_ACTION))
def hard_coded_range_if(self, input_nodes, context):
	ip_address = context['ip address'] 	# we assume the provided context
										# parameter is a Dict with 'ip address'
	
	# hard-coded values that could be constants generated by children nodes
	lower_ip = '10.0.0.0'
	upper_ip = '192.255.255.255'
	
	# see if input IP address is within range
	between = True
	for octet, value in enumerate(ip_address.split('.')):
		lower_value = int(lower_ip.split('.')[octet])
		upper_value = int(upper_ip.split('.')[octet])
		value = int(value)

		if lower_value == value == upper_value:
			continue
		elif lower_value <= value <= upper_value:
			break
		else:
			between = False
			break

	print(input_nodes)
	if between:
		test = input_nodes[0].execute(context)
		return test
	else:
		test2 = input_nodes[1].execute(context)
		return test2


# only attackers can use this primitive, it's data type is IP_ACTION, and it
# does not have any children (so it's a leaf node)
@GeneticTree.declarePrimitive(ATTACKER, IP_ACTION, ())
def action0(self, input_nodes, context):
	ip_address = context['ip address'] 	# we assume the provided context
										# parameter is a Dict with 'ip address'
	print('I performed action 0 on address', ip_address)
	return "i have done this"

# only attackers can use this primitive, it's data type is IP_ACTION, and it
# does not have any children (so it's a leaf node)
@GeneticTree.declarePrimitive(ATTACKER, IP_ACTION, ())
def action1(self, input_nodes, context):
	ip_address = context['ip address'] 	# we assume the provided context
										# parameter is a Dict with 'ip address'
	print('I performed action 1 on address', ip_address)
	return "i have done this"


# only attackers can use this primitive, it's data type is IP_ACTION, and it 
# requires 2 IP_ADDRESS-type and 2 IP_ACTION-type children nodes.
@GeneticTree.declarePrimitive(ATTACKER, IP_ACTION, (IP_ADDRESS, IP_ADDRESS, IP_ACTION, IP_ACTION))
def dynamic_range_if(self, input_nodes, context):
	ip_address = context['ip address'] 	# we assume the provided context
										# parameter is a Dict with 'ip address'
	
	lower_ip = input_nodes[0].execute(context)
	upper_ip = input_nodes[1].execute(context)

	# swap IP addresses if they are out of order
	for octet in range(4):
		lower_value = int(lower_ip.split('.')[octet])
		upper_value = int(upper_ip.split('.')[octet])

		if lower_value == upper_value:
			continue
		elif lower_value < upper_value:
			break
		else:
			lower_ip, upper_ip = upper_ip, lower_ip
	
	# see if input IP address is within range
	between = True
	for octet, value in enumerate(ip_address.split('.')):
		lower_value = int(lower_ip.split('.')[octet])
		upper_value = int(upper_ip.split('.')[octet])
		value = int(value)

		if lower_value == value == upper_value:
			continue
		elif lower_value <= value <= upper_value:
			break
		else:
			between = False
			break

	print(input_nodes)
	if between:
		input_nodes[2].execute(context)
	else:
		input_nodes[3].execute(context)

# define a primitive that generates a constant value upon first call
@GeneticTree.declarePrimitive(ATTACKER, IP_ADDRESS, ())
def constant_IP_address(self, input_nodes, context):
	if self.value is None:
		octets = [random.randint(0,255) for _ in range(4)]
		self.value = '{0}.{1}.{2}.{3}'.format(*octets)
		print(self.value)
	return self.value